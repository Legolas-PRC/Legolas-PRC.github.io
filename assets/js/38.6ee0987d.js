(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{471:function(e,t,n){"use strict";n.r(t);var r=n(10),s=Object(r.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("关于mock\nhttps://mp.weixin.qq.com/s/hX_RIYs-nBnqVwdq5B4rhg")]),e._v(" "),t("p",[e._v("测试替身理论：\ndummy\nfake\nspy: 一个真实对象，其中的方法实现都是真实的，会记录其方法调用的相关信息（如调用频次）\nstub: 对真实对象的简单实现，返回预定义的数据，是mock的子集\nmock: 模拟的对象，在测试中自定义方法行为，记录方法调用")]),e._v(" "),t("p",[e._v("框架：mockito\n@InjectMocks：创建实例，其余用@Mock或@Spy创建的对象将被注入到该实例中，一般是待测对象；")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('@Mock：实例化一个mock对象，所有方法都被模拟空实现，返回默认值null/0，适用于普通类、接口和虚基类\n        等价于Mockito.mock();方法\n       可以通过Mockito.when(nbService.getName()).thenReturn("NbService");\n        或Mockito.doReturn("NbService").when(nbService).getName();模拟方法行为\n\n@Spy：实例化真实对象，s所有方法实现都是真实的，会记录该对象的交互\n        等价于Mockito.spy()\n        可以通过when().then()或doReturn().when()来模拟方法行为(打桩)\n')])])]),t("p",[e._v('定义被测对象\n模拟依赖对象\n注入依赖对象\n模拟依赖方法\n可以根据各种条件模拟各种行为：调用原方法，返回固定值，执行lambda表达式，啥也不干等\n验证依赖方法调用行为\n验证方法调用的入参:\neg.验证testDAO.re()方法是否被调用，且入参为"你好"\nMockito.verify(testDAO).re("你好");\n方法调用次数:\neg.testDAO.re("你好")被调用了两次\nMockito.verify(testDAO, Mockito.times(2)).re("你好");\n验证方法调用并捕获入参:\neg.捕获入参\nArgumentCaptor'),t("String",[e._v(" captor = ArgumentCaptor.forClass(String.class);或者@Captor\nMockito.verify(testDAO).re(captor.capture());\nString value = captor.getValue();\n验证数据\n断言 junit4:Assert;junit5:Assertion\n异常处理\n验证依赖对象"),t("br"),e._v("\n模拟对象方法是否被调用\nMockito.verfyNoInteractions();\n清除方法调用标记\nMockito.clearInvocations();")])],1),e._v(" "),t("p",[e._v("junit\njunit4 springboot2.2以前内置\njunit5 sb2.2及之后")]),e._v(" "),t("p",[e._v("junit4源码：\n入口：\npublic static void main(String[] args) {\nJUnitCore jUnitCore = new JUnitCore();\nRequest request = Request.aClass(MainTest.class);\nResult result = jUnitCore.run(request.getRunner());\n}")]),e._v(" "),t("p",[e._v("JunitCore:门面")]),e._v(" "),t("p",[e._v("Request：对测试类的抽象封装\nan abstract description of tests to be run.\nThe flow when JUnit runs tests is that\na Request specifies some tests to be run ->\na Runner is created for each class implied by the Request ->\nthe Runner returns a detailed Description which is a tree structure of the tests to be run.")]),e._v(" "),t("p",[e._v("public class ClassRequest extends Request {\nprivate final Object runnerLock = new Object();")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("private final Class<?> fTestClass;\nprivate final boolean canUseSuiteMethod;\nprivate volatile Runner runner;\n\npublic ClassRequest(Class<?> testClass, boolean canUseSuiteMethod) {\n    this.fTestClass = testClass;\n    this.canUseSuiteMethod = canUseSuiteMethod;\n}\n\npublic ClassRequest(Class<?> testClass) {\n    this(testClass, true);\n}\n\n@Override\npublic Runner getRunner() {\n    if (runner == null) {\n        synchronized (runnerLock) {\n            if (runner == null) {\n                runner = new AllDefaultPossibilitiesBuilder(canUseSuiteMethod).safeRunnerForClass(fTestClass);\n            }\n        }\n    }\n    return runner;\n}\n")])])]),t("p",[e._v("}")]),e._v(" "),t("p",[e._v("// 根据传入的测试类判断用哪个Runner\npublic Runner safeRunnerForClass(Class<?> testClass) {\ntry {\nreturn runnerForClass(testClass);\n} catch (Throwable e) {\nreturn new ErrorReportingRunner(testClass, e);\n}\n}")]),e._v(" "),t("p",[e._v("public Runner runnerForClass(Class<?> testClass) throws Throwable {\nList"),t("RunnerBuilder",[e._v(" builders = Arrays.asList(\nignoredBuilder(),\nannotatedBuilder(),\nsuiteMethodBuilder(),\njunit3Builder(),\njunit4Builder());")])],1),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("for (RunnerBuilder each : builders) {\n    Runner runner = each.safeRunnerForClass(testClass);\n    if (runner != null) {\n        return runner;\n    }\n}\nreturn null;\n")])])]),t("p",[e._v("}")]),e._v(" "),t("p",[e._v("Runner:执行测试用例并将重要事件通知给RunNotifier")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("public void run(final RunNotifier notifier) {\n    EachTestNotifier testNotifier = new EachTestNotifier(notifier,\n            getDescription());\n    try {\n        Statement statement = classBlock(notifier);\n        statement.evaluate();\n    } catch (AssumptionViolatedException e) {\n        testNotifier.addFailedAssumption(e);\n    } catch (StoppedByUserException e) {\n        throw e;\n    } catch (Throwable e) {\n        testNotifier.addFailure(e);\n    }\n}\n\n// childrenInvoker里找到全部test方法，包装成Staement\n// 依次执行before,method,after\nprotected Statement classBlock(final RunNotifier notifier) {\n    Statement statement = childrenInvoker(notifier);\n    if (!areAllChildrenIgnored()) {\n        statement = withBeforeClasses(statement);\n        statement = withAfterClasses(statement);\n        statement = withClassRules(statement);\n    }\n    return statement;\n}\n\n// BlockJunit4ClassRunner\nprotected Statement methodBlock(FrameworkMethod method) {\n    Object test;\n    try {\n        test = new ReflectiveCallable() {\n            @Override\n            protected Object runReflectiveCall() throws Throwable {\n                return createTest();\n            }\n        }.run();\n    } catch (Throwable e) {\n        return new Fail(e);\n    }\n\n    Statement statement = methodInvoker(method, test);\n    statement = possiblyExpectingExceptions(method, test, statement);\n    statement = withPotentialTimeout(method, test, statement);\n    statement = withBefores(method, test, statement);\n    statement = withAfters(method, test, statement);\n    statement = withRules(method, test, statement);\n    return statement;\n}\n")])])]),t("p",[e._v("public class RunBefores extends Statement {\nprivate final Statement next;\nprivate final Object target;\nprivate final List"),t("FrameworkMethod",[e._v(" befores;")])],1),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("public RunBefores(Statement next, List<FrameworkMethod> befores, Object target) {\n    this.next = next;\n    this.befores = befores;\n    this.target = target;\n}\n\n@Override\npublic void evaluate() throws Throwable {\n    for (FrameworkMethod before : befores) {\n        before.invokeExplosively(target);\n    }\n    next.evaluate();\n}\n")])])]),t("p",[e._v("}")]),e._v(" "),t("p",[e._v("Statement:封装了可执行的行为，如@Before，@BeforeClass，@Test等\n"),t("img",{attrs:{src:"image.png",alt:"alt text"}}),e._v("\n方法调用：通过反射执行\npublic Object invokeExplosively(final Object target, final Object... params)\nthrows Throwable {\nreturn new ReflectiveCallable() {\n@Override\nprotected Object runReflectiveCall() throws Throwable {\nreturn method.invoke(target, params);\n}\n}.run();\n}")]),e._v(" "),t("p",[e._v("Result")]),e._v(" "),t("p",[e._v("public Result run(Runner runner) {\nResult result = new Result();\nRunListener listener = result.createListener();\nnotifier.addFirstListener(listener);\ntry {\nnotifier.fireTestRunStarted(runner.getDescription());\nrunner.run(notifier);\nnotifier.fireTestRunFinished(result);\n} finally {\nremoveListener(listener);\n}\nreturn result;\n}")]),e._v(" "),t("p",[e._v("RunNotifier，EachTestNotifier\nRunListener\nDescription")]),e._v(" "),t("p",[e._v("1.将测试类包装成Request\n2.根据测试类得到Runner\n3.执行Runner的public abstract void run(RunNotifier notifier);方法\n4.将测试方法，before，after方法等包装成Statement,依次执行\n5.各个执行节点都会调用notifier的对应方法，通知listener执行对应操作")]),e._v(" "),t("p",[e._v("有趣的设计\n单例\nlistener\n方法入参里的final\nbuilder\n策略模式\nReflectiveCallable")]),e._v(" "),t("p",[e._v("@AutoWired 注入Map")])])}),[],!1,null,null,null);t.default=s.exports}}]);